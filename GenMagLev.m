function [ Dat ] = GenMagLev( varargin )
% This function generates input-output data.
% Usage: [ t, u, y ] = GenMagLev( Fnc, Sys, Sim, Excite, 'Training' / 'Testing' );

        % Extract required parameters
        Fnc = varargin{ 1 };
        Sys = varargin{ 2 };
        Sim = varargin{ 3 };
        Excite = varargin{ 4 };
        TypeOfData = varargin{ nargin };
        
        SimData = Fnc.SimData;
        
        if strcmpi( TypeOfData, 'Training' )
        % Data is generated by keeping a few things in mind. They are:
        % 1.    The generated data should capture both transient and steady-state
        %        behaviour. 
        % 2.    The APRBS ( Skyline function ) is combination of pulses. These
        %        pulses remain at different amplitudes (AlfaU) for different
        %        duration (TauU). Both AlfaU & TauU are range-bound and are
        %        randomly distributed. Pulses of shorter duration capture transient
        %        behaviour, and pulses of longer duration capture steady-state
        %        behaviour. This sequence hence covers the entire range of
        %        amplitudes and frequencies under which the system is intended to
        %        be operated.
        % 3.    Delay associated with the system is around 4.5s under the current 
        %        system parameters. Hence, [ TauUmin, TauUmax ] can be set as 
        %        [ 0.01, 5.0 ]. However, this gives poor transient performance.
        %        Hence, data is generated with [ TauUmin, TauUmax ] = [ 0.01, 1.0 ]
        %        for the first 100s and [ TauUmin, TauUmax ] = [ 1.0, 5.0 ] for the
        %        next 300s. The first 100s will usually be of short pulses and
        %        captures transent behaviours. The next 200s consists of longer
        %        pulses and captures steady-state behaviour.
        % 4.    The sequence is generated with dt = 0.01s.
        % 5.    The minimum & maximum voltage that can be supplied to the armature
        %        of electromagnet is [ AlfaUmin, AlfaUmax ] = [0.0, 4.0].
        % 6.    To avoid overfitting, one of the methods used in the Matlab Neural
        %       Network Toolbox is "Early stopping", which necessiates division of
        %       data into three different sets - TRAINing, VALIDATION & TESTing. It
        %       is also essential that these three sets of data be correlated. But,
        %       based on the way data was generated here ( see Step 3 ), any kind
        %       of division affects this inter-correlation. Therefore, data is
        %       generated as follows in Step 7.
        % 7.   Three different sets of data as mentioned in Step 3 is generated and
        %       combined.

        SimTemp.dt = Sim.dt;
        Tend = Sim.Training;
        if iscolumn( Tend )
                Tend = Tend.';
        end
        Tstart = cat( 2, 0.0, Tend( 1:end-1 ) + 0.01 );
        SysTemp = Sys;
        ExciteTemp = Excite;
        t= []; u = []; y = [];

        for i = 1:length( Tstart )
                if mod( i, 2 ) == 0
                        ExciteTemp.TauUmin = Excite.TauUminSS;
                        ExciteTemp.TauUmax = Excite.TauUmaxSS;
                else
                        ExciteTemp.TauUmin = Excite.TauUminTR;
                        ExciteTemp.TauUmax = Excite.TauUmaxTR;
                end
                SimTemp.Tstart = Tstart( i ); SimTemp.Tend = Tend( i );
                [ Dat.T, Dat.U, Dat.Y ] = SimData( SysTemp, ...
                                      SimTemp, ExciteTemp, 'Actual' );
                SysTemp.Yo = Dat.Y( end, : );
                t = [ t; Dat.T ]; u = [ u; Dat.U ]; y = [ y; Dat.Y ];
        end
        clear Dat;
        Dat.t = t; Dat.u = u; Dat.y = y;

        elseif strcmpi( TypeOfData, 'Testing' )

                ExciteTemp = Excite;
                ExciteTemp.TauUmin = varargin{ 2 }( 1 );
                ExciteTemp.TauUmax = varargin{ 2 }( 2 );

                [ Dat.t, Dat.u, Dat.y ] = SimData( Sys, Sim, ExciteTemp, 'Actual' );
                
        elseif strcmpi( TypeOfData, 'Robust training' )

                TauMin = Excite.TauUmin;
                TauMax = Excite.TauUmax;
                dTau = Excite.dTau;
                % TauUmin = [ 0.01 0.5 1.0 ];
                % TauUmax = [ 1.0 1.5 2.0];
                TauUmin = [ TauMin ( dTau ):( dTau ):( TauMax - dTau ) ];
                TauUmax = [ dTau ( dTau + dTau ):( dTau ):( TauMax ) ];
                
                TauLen = length( TauUmin );
                idx1 = randperm( TauLen );
                idx2 = randperm( TauLen );
                idx3 = randperm( TauLen );
                
                TauUmin = [ TauUmin( idx1 ) TauUmin( idx2 ) TauUmin( idx3 ) ];
                TauUmax = [ TauUmax( idx1 ) TauUmax( idx2 ) TauUmax( idx3 ) ];

                [ Dat ] = RobustSim( Fnc, Sys, Sim, Excite, TauUmin, TauUmax );
                Sim.Tend = Dat.t( end );
                
        elseif strcmpi( TypeOfData, 'Robust testing' )

                TauMin = Excite.TauUmin;
                TauMax = Excite.TauUmax;
                dTau = Excite.dTau;
                % TauUmin = [ 0.01 0.5 1.0 ];
                % TauUmax = [ 1.0 1.5 2.0];
                TauUmin = [ TauMin ( dTau ):( dTau ):( TauMax - dTau ) ];
                TauUmax = [ dTau ( dTau + dTau ):( dTau ):( TauMax ) ];
                % disp( [ TauUmin.' TauUmax.' ] );

                TauLen = length( TauUmin );

                idx = randperm( TauLen );
                TauUmin = TauUmin( idx );
                TauUmax = TauUmax( idx );
                
                [ Dat ] = RobustSim( Fnc, Sys, Sim, Excite, TauUmin, TauUmax );
                Sim.Tend = Dat.t( end );

        end
        
end

function [ Dat ] = RobustSim( Fnc, Sys, Sim, Excite, TauUmin, TauUmax )

        set = 1;
        SimTmp = Sim;
        SysTmp = Sys;
        ExciteTmp = Excite;
        SimData = Fnc.SimData;
        
        TauLen = length( TauUmin );

        t = []; u = []; y = [];
        while set <= TauLen
                ExciteTmp.TauUmin = TauUmin( set );
                ExciteTmp.TauUmax = TauUmax( set );
                [ dat.T, dat.U, dat.Y, iter ] = SimData( SysTmp, SimTmp, ExciteTmp, 'Actual' );
%                         disp( [ 'Set: ' num2str( set ) ',        Iteration: ' num2str( iter ) ] );
                if iter == 0
                        set = set + 1;
                        t = [ t; dat.T ];
                        u = [ u; dat.U ];
                        y = [ y; dat.Y ];
                        SimTmp.Tstart = SimTmp.Tend + SimTmp.dt;
                        SimTmp.Tend = set * Sim.Tend;
                        SysTmp.Yo = dat.Y( end, : );
%                                 disp( ' ' );
                end
        end

        Dat.t = t; Dat.u = u; Dat.y = y;

end